<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Chef</title>

    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700&family=Share+Tech+Mono&display=swap"
        rel="stylesheet">
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Libraries for parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        /* --- TON CSS ORIGINAL (INTEGRÉ & ADAPTÉ) --- */
        :root {
            --bg-color: #060606;
            --card-bg: #0d1216;
            --text-color: #e6e6e6;
            --neon-orange: #FF6B00;
            --neon-green: #0aff47;
            --neon-blue: #13aff0;
            --neon-purple: #bd00ff;
            --neon-red: #ff003c;
            --cyber-font: 'Cinzel', serif;
            --code-font: 'JetBrains Mono', monospace;
            --ui-font: 'Inter', sans-serif;
            --alert-red: #ff0055;
            --sysbar-height: 50px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--ui-font);
            line-height: 1.6;
            overflow-x: hidden;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)),
                linear-gradient(0deg, rgba(255, 107, 0, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 0, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            /* padding-top: var(--sysbar-height); */
            position: sticky;
            top: 0;
            z-index: 1001;
        }

        /* --- GLOBAL SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--neon-blue);
        }

        /* --- SYSTEM BAR --- */
        /* --- SYSTEM BAR --- */
        .sys-bar {
            /* Removed fixed/sticky, handled by wrapper */
            width: 100%;
            height: auto;
            min-height: var(--sysbar-height);
            padding: 10px 20px;
            background: rgba(9, 13, 16, 0.95);
            /* border-bottom: 1px solid var(--neon-blue); REMOVED BORDER TO GLUE */
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
            /* box-shadow: 0 0 15px rgba(19, 175, 240, 0.1); REMOVED SHADOW TO GLUE */
        }

        .sys-title {
            font-family: var(--cyber-font);
            color: var(--text-color);
            font-weight: bold;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sys-title i {
            color: var(--neon-orange);
        }

        .sys-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        /* --- CONTROLS & INPUTS --- */
        .cyber-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 6px 12px;
            font-family: var(--code-font);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .cyber-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .cyber-btn.danger {
            border-color: var(--neon-red);
            color: var(--neon-red);
        }

        .cyber-btn.danger:hover {
            background: var(--neon-red);
            color: white;
        }

        .cyber-btn.action {
            border-color: var(--neon-orange);
            color: var(--neon-orange);
        }

        .cyber-btn.action:hover {
            background: var(--neon-orange);
            color: black;
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            max-width: 400px;
            margin: 0 20px;
        }

        .cyber-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            color: var(--neon-green);
            padding: 8px 12px;
            font-family: var(--code-font);
            border-radius: 4px;
            outline: none;
        }

        .cyber-input:focus {
            border-color: var(--neon-green);
            box-shadow: 0 0 5px rgba(10, 255, 71, 0.3);
        }

        .search-clear-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            display: none;
            font-size: 0.9rem;
            padding: 5px;
        }

        .search-clear-btn:hover {
            color: var(--neon-red);
        }

        /* --- MAIN LAYOUT --- */
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            margin-top: 15px;
            padding: 0px 20px 20px 20px;
            transition: filter 0.3s ease;
        }

        /* Blur effect when modal is open */
        body.modal-open .app-container,
        body.modal-open .sys-bar {
            filter: blur(8px);
            pointer-events: none;
        }

        /* Sticky Header Wrapper */
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: #0d1216;
            /* Fallback */
        }

        /* Ensure Toolbar is below System Bar */
        .toolbar {
            /* Removed sticky from here, handled by wrapper */
            background: rgba(13, 18, 22, 0.95);
            /* Glass-ish */
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #333;
            width: 100%;
            margin-top: 0;
        }

        .toolbar-inner {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .filters2 {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tag-pill {
            padding: 4px 10px;
            border-radius: 12px;
            background: #222;
            color: #888;
            font-size: 0.8rem;
            cursor: pointer;
            border: 1px solid transparent;
            font-family: var(--code-font);
        }

        .tag-pill.active {
            border-color: var(--neon-purple);
            color: var(--neon-purple);
            background: rgba(189, 0, 255, 0.1);
        }

        /* --- RECIPE GRID (DEFAULT CARD VIEW) --- */
        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
        }

        body.modal-open {
            /* Keep existing behavior if any, but adding explicit no-scroll */
            overflow: hidden;
        }

        body.no-scroll {
            overflow: hidden !important;
        }

        /* --- LIST VIEW --- */
        .recipe-grid.list-view {
            grid-template-columns: 1fr;
        }

        /* --- BIG GRID VIEW (NEW) --- */
        .recipe-grid.big-grid-view {
            grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            /* Colonnes plus larges */
        }

        /* --- RECIPE CARD --- */
        .recipe-card {
            background: var(--card-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            height: 100%;
        }

        .recipe-grid.list-view .recipe-card {
            flex-direction: row;
            height: 150px;
        }

        .recipe-card:hover {
            transform: translateY(-5px);
            border-color: var(--neon-blue);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5), 0 0 5px rgba(19, 175, 240, 0.3);
        }

        .recipe-card.selected {
            border-color: var(--neon-orange);
            box-shadow: 0 0 10px var(--neon-orange);
        }

        /* Card Images Sizes based on view */
        .card-img-container {
            height: 200px;
            /* Default height */
            overflow: hidden;
            position: relative;
            background: #000;
            transition: height 0.3s ease;
        }

        .recipe-grid.list-view .card-img-container {
            width: 200px;
            height: 100%;
            flex-shrink: 0;
        }

        /* Big Grid Image Height */
        .recipe-grid.big-grid-view .card-img-container {
            height: 450px;
            /* Much taller image */
        }

        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s;
            pointer-events: none;
            /* Let container handle swipe events */
        }

        .card-img-indicator {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-family: var(--code-font);
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0.8;
        }

        .fav-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.4);
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 5;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }

        .fav-btn:hover {
            color: var(--neon-red);
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .fav-btn.active {
            color: var(--neon-red);
            text-shadow: 0 0 10px var(--neon-red);
            opacity: 1;
        }

        /* Mobile Optimization for Fav Btn */
        @media (max-width: 900px) {
            .fav-btn {
                font-size: 1rem;
                width: 24px;
                height: 24px;
                background: transparent;
                /* More discrete */
                top: 2px;
                right: 2px;
            }
        }

        .card-content {
            padding: 15px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .card-title {
            font-family: var(--cyber-font);
            color: white;
            font-size: 1.2rem;
            margin-bottom: 5px;
            text-overflow: ellipsis;
        }

        /* Bigger Title in Big Grid */
        .recipe-grid.big-grid-view .card-title {
            font-size: 1.8rem;
        }

        .card-meta {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
            color: #888;
            font-family: var(--code-font);
            margin-bottom: 10px;
        }

        .card-meta i {
            color: var(--neon-green);
            margin-right: 5px;
        }

        .card-tags {
            margin-top: auto;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .mini-tag {
            font-size: 0.7rem;
            color: var(--neon-purple);
            border: 1px solid var(--neon-purple);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .select-check {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            z-index: 10;
            cursor: pointer;
            display: none;
            /* Show only in select mode */
        }

        .select-mode .select-check {
            display: block;
        }

        .select-check:checked {
            background: var(--neon-orange);
            border-color: var(--neon-orange);
        }

        /* --- DETAILED MODAL (The Portal) --- */
        .modal-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal-wrapper.active {
            display: flex;
            opacity: 1;
        }

        .recipe-modal {
            width: 90%;
            max-width: 1000px;
            height: 90vh;
            background: #0d1216;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-radius: 8px;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal-wrapper.active .recipe-modal {
            transform: scale(1);
        }

        .modal-header {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Modal Grid Layout */
        .modal-content-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            min-height: 100%;
        }

        .modal-sidebar {
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .modal-main {
            padding: 30px;
            background: rgba(255, 255, 255, 0.01);
        }

        /* Gallery */
        .gallery-container {
            width: 100%;
            aspect-ratio: 4/3;
            background: transparent;
            /* Changed from #000 */
            margin-bottom: 10px;
            position: relative;
            border: none;
            /* Changed from 1px solid #333 */
        }

        .main-photo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 25px;
            /* Added radius */
        }

        .gallery-thumbs {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 5px;
        }

        .thumb {
            width: 60px;
            height: 60px;
            object-fit: cover;
            opacity: 0.6;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .thumb.active {
            opacity: 1;
            border-color: var(--neon-orange);
        }

        /* Ingredients */
        .ingredient-list {
            list-style: none;
            margin-top: 10px;
        }

        .ingredient-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed #333;
            font-size: 0.95rem;
        }

        .ing-qty {
            color: var(--neon-green);
            font-family: var(--code-font);
            font-weight: bold;
        }

        .servings-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #222;
            padding: 5px 10px;
            border-radius: 20px;
            width: fit-content;
            margin-bottom: 10px;
        }

        .servings-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .servings-val {
            font-family: var(--code-font);
            color: var(--neon-orange);
            min-width: 20px;
            text-align: center;
        }

        /* Instructions (Markdown) */
        .instructions-content {
            font-family: var(--ui-font);
            color: #ddd;
            line-height: 1.6;
        }

        .instructions-content p {
            margin-bottom: 1rem;
        }

        .instructions-content h1,
        .instructions-content h2,
        .instructions-content h3 {
            font-family: var(--cyber-font);
            color: var(--neon-blue);
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .instructions-content ul,
        .instructions-content ol {
            padding-left: 20px;
            margin-bottom: 1rem;
        }

        .instructions-content li {
            margin-bottom: 0.5rem;
        }

        .instructions-content strong {
            color: white;
        }

        .instructions-content img,
        .instructions-content video {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #333;
        }

        /* Responsive */
        @media (max-width: 800px) {
            .modal-content-grid {
                grid-template-columns: 1fr;
            }

            .modal-sidebar {
                border-right: none;
                border-bottom: 1px solid #333;
            }

            .recipe-grid.big-grid-view {
                grid-template-columns: 1fr;
            }

            /* Mobile always 1 column but big pics */
            .recipe-grid.big-grid-view .card-img-container {
                height: 300px;
            }
        }

        /* --- EDIT FORM OVERLAY --- */
        .edit-form-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-label {
            color: var(--neon-blue);
            font-size: 0.8rem;
            font-family: var(--code-font);
        }

        .form-textarea {
            min-height: 150px;
            resize: vertical;
        }

        /* Load More Button & Sentinel */
        .load-more-container {
            text-align: center;
            margin-top: 30px;
            margin-bottom: 50px;
            height: 20px;
            /* Gives observer something to hit */
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        /* --- TOAST NOTIFICATION --- */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--neon-green);
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            font-family: var(--code-font);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 3000;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .toast.show {
            opacity: 1;
        }

        /* --- RICH EDITOR --- */
        .rich-editor {
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            color: #ddd;
            padding: 15px;
            font-family: var(--ui-font);
            border-radius: 4px;
            white-space: pre-wrap;
            /* Preserve whitespace */
        }

        .rich-editor:focus {
            border-color: var(--neon-green);
            outline: none;
            box-shadow: 0 0 5px rgba(10, 255, 71, 0.3);
        }

        .rich-editor h1 {
            font-size: 1.8em;
            color: var(--neon-orange);
            border-bottom: 1px solid #333;
            margin-top: 0.5em;
        }

        .rich-editor h2 {
            font-size: 1.5em;
            color: var(--neon-blue);
            margin-top: 0.5em;
        }

        .rich-editor h3 {
            font-size: 1.2em;
            color: var(--neon-purple);
            margin-top: 0.5em;
        }

        .rich-editor ul,
        .rich-editor ol {
            margin-left: 20px;
        }

        .media-wrapper {
            display: inline-block;
            position: relative;
            margin: 5px;
            vertical-align: middle;
            cursor: move;
            user-select: none;
        }

        .media-wrapper img,
        .media-wrapper video {
            max-height: 150px;
            /* Thumbnail size */
            max-width: 100%;
            border: 1px solid var(--neon-blue);
            border-radius: 4px;
            display: block;
        }

        .media-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--neon-red);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .media-delete:hover {
            transform: scale(1.1);
        }

        /* --- EDIT IMAGE LIST --- */
        .edit-image-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            min-height: 80px;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 4px;
        }

        .edit-image-item {
            position: relative;
            width: 80px;
            height: 80px;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .edit-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .edit-image-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- TAGS SELECTOR --- */
        .tags-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            max-height: 100px;
            overflow-y: auto;
        }

        .tag-pill.selectable {
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .tag-pill.selectable:hover {
            opacity: 1;
            background: #333;
        }

        .tag-pill.selectable.selected {
            opacity: 1;
            border-color: var(--neon-green);
            color: var(--neon-green);
            background: rgba(10, 255, 71, 0.1);
        }

        .edit-image-item.dragging {
            opacity: 0.5;
            border-color: var(--neon-orange);
            box-shadow: 0 0 10px var(--neon-orange);
        }

        /* --- NEW EDIT LAYOUT --- */
        .edit-layout-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .edit-header {
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .edit-main-grid {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .edit-sidebar {
            width: 320px;
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .edit-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
            min-width: 0;
        }

        .editor-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #333;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            background: #222;
            border: 1px solid #444;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--code-font);
            font-size: 0.8rem;
        }

        .toolbar-btn:hover {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
        }

        .split-editor {
            display: flex;
            flex: 1;
            gap: 15px;
            overflow: hidden;
        }

        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-pane-label {
            font-family: var(--code-font);
            color: #666;
            font-size: 0.75rem;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .rich-editor.scrollable {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            max-height: none;
            font-family: var(--code-font);
            /* Use code font for Markdown editing */
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Preview Mode Styles */
        .rich-editor.preview-mode img,
        .rich-editor.preview-mode video {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
            display: block;
            margin: 10px 0;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .filters {
            display: flex;
            gap: 10px;
            /* margin-top: 10px; */
            /* border-top: 1px solid #333; */
            /* padding-top: 10px; */
            flex-wrap: wrap;
            flex-direction: row;
            justify-content: flex-start;
        }

        /* --- MOBILE OPTIMIZATIONS --- */
        .mobile-edit-tabs {
            display: none;
            /* Hidden on desktop */
            gap: 10px;
            margin-top: 10px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .mobile-tab-btn {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            color: #888;
            padding: 8px;
            font-family: var(--code-font);
            cursor: pointer;
            border-radius: 4px;
            text-align: center;
        }

        .mobile-tab-btn.active {
            background: var(--neon-blue);
            color: #000;
            border-color: var(--neon-blue);
            font-weight: bold;
        }

        /* Default Desktop Styles for New Controls */
        #secondaryControls {
            display: flex;
            gap: 5px;
        }

        #mobileMenuBtn {
            display: none;
        }

        @media (max-width: 900px) {

            /* System Bar */
            .sys-bar {
                height: auto;
                flex-wrap: wrap;
                padding: 10px;
                gap: 5px;
                align-items: center;
                position: sticky;
                top: 0;
                z-index: 1001;
                background: #0d1216;
                border-bottom: 1px solid #333;
            }

            .sys-title {
                width: auto;
                margin-bottom: 0;
                font-size: 1.2rem;
            }

            .search-container {
                width: 100%;
                order: 3;
                /* Search on new line */
                margin-top: 5px;
            }

            .sys-controls {
                width: auto;
                flex-grow: 1;
                justify-content: flex-end;
                gap: 5px;
                order: 2;
            }

            #mobileMenuBtn {
                display: flex;
            }

            /* Compact Buttons on Mobile */
            .sys-controls .cyber-btn {
                padding: 6px 10px;
            }

            .sys-controls .btn-text {
                display: none;
            }

            /* Floating Menu for Secondary Controls */
            #secondaryControls {
                display: none;
                position: absolute;
                top: 50px;
                right: 10px;
                flex-direction: column;
                background: rgba(0, 0, 0, 0.95);
                border: 1px solid var(--neon-blue);
                padding: 10px;
                border-radius: 8px;
                z-index: 1000;
                gap: 10px;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            }

            #secondaryControls.show-menu {
                display: flex;
            }

            #secondaryControls .cyber-btn {
                width: 100%;
                text-align: left;
                justify-content: flex-start;
            }

            #secondaryControls .btn-text {
                display: inline;
                /* Show text in menu */
            }




            .toolbar-inner {
                padding: 5px 10px;
                /* Smaller padding on mobile */
            }



            #recipeCount {
                display: none;
            }

            /* Horizontal Scroll Tags */
            .filters#tagFilters {
                flex-wrap: nowrap;
                overflow-x: auto;
                white-space: nowrap;
                padding-bottom: 5px;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                padding-top: 0px;
                /* Firefox */
                width: 100%;
                /* Ensure full width */
            }

            .filters#tagFilters::-webkit-scrollbar {
                display: none;
                /* Chrome/Safari */
            }

            /* Sort Select on Mobile */
            #sortSelect {
                width: auto !important;
                padding: 4px;
                font-size: 0.8rem;
            }

            /* 3 Columns Grid on Mobile */
            /* 3 Columns Grid on Mobile (Default View Only) */
            /* 3 Columns Grid on Mobile (Default View Only) */
            .recipe-grid:not(.list-view):not(.big-grid-view) {
                grid-template-columns: repeat(3, 1fr);
                gap: 5px;
            }

            /* Mobile Card Styling (Square-ish) - Default View Only */
            .recipe-grid:not(.list-view):not(.big-grid-view) .recipe-card {
                border-radius: 4px;
                background: var(--card-bg);
                border: none;
            }

            .recipe-grid:not(.list-view):not(.big-grid-view) .card-img-container {
                height: 0;
                padding-bottom: 100%;
                border-radius: 4px;
            }

            .recipe-grid:not(.list-view):not(.big-grid-view) .card-img {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border-radius: 4px;
            }

            .recipe-grid:not(.list-view):not(.big-grid-view) .card-content {
                padding: 5px 0 0 0;
                flex-grow: 0;
            }

            .recipe-grid:not(.list-view):not(.big-grid-view) .card-title {
                font-size: 0.7rem;
                line-height: 1.1;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-bottom: 0;
                text-align: center;
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
            }

            .recipe-grid:not(.list-view):not(.big-grid-view) .card-tags {
                display: none;
            }

            /* --- MOBILE LIST VIEW OVERRIDES --- */
            .recipe-grid.list-view {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .recipe-grid.list-view .recipe-card {
                flex-direction: row;
                height: auto;
                background: var(--card-bg);
                border: 1px solid rgba(255, 255, 255, 0.1);
                padding: 0;
            }

            .recipe-grid.list-view .card-img-container {
                width: 100px;
                height: 100px;
                padding-bottom: 0;
                /* Reset square aspect */
                border-radius: 4px 0 0 4px;
            }

            .recipe-grid.list-view .card-img {
                position: relative;
                /* Reset absolute */
                width: 100%;
                height: 100%;
            }

            .recipe-grid.list-view .card-content {
                padding: 10px;
                text-align: left;
                justify-content: center;
            }

            .recipe-grid.list-view .card-title {
                font-size: 1rem;
                text-align: left;
                margin-bottom: 5px;
                white-space: normal;
            }

            .recipe-grid.list-view .card-tags {
                display: flex;
                /* Show tags in list view */
                flex-wrap: wrap;
                gap: 4px;
            }

            /* --- MOBILE BIG GRID OVERRIDES --- */
            .recipe-grid.big-grid-view {
                grid-template-columns: 1fr;
                /* 1 Column for Big Grid */
                gap: 20px;
            }

            .recipe-grid.big-grid-view .recipe-card {
                background: var(--card-bg);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
            }

            .recipe-grid.big-grid-view .card-img-container {
                height: 300px;
                /* Taller image for big grid */
                padding-bottom: 0;
                border-radius: 8px 8px 0 0;
            }

            .recipe-grid.big-grid-view .card-img {
                position: relative;
                width: 100%;
                height: 100%;
            }

            .recipe-grid.big-grid-view .card-content {
                padding: 15px;
            }

            .recipe-grid.big-grid-view .card-title {
                font-size: 1.2rem;
                text-align: left;
                margin-bottom: 10px;
                white-space: normal;
                -webkit-line-clamp: unset;
            }

            .recipe-grid.big-grid-view .card-tags {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }

            /* Edit Modal Mobile Layout */
            .recipe-modal {
                width: 100% !important;
                height: 100% !important;
                max-height: 100% !important;
                border-radius: 0;
                border: none;
            }

            .edit-layout-container {
                height: 100%;
            }

            .mobile-edit-tabs {
                display: flex;
            }

            .edit-main-grid {
                position: relative;
            }

            .edit-sidebar,
            .edit-workspace {
                width: 100%;
                display: none;
                /* Hidden by default, toggled by tabs */
                border-right: none;
            }

            .edit-sidebar.active-tab,
            .edit-workspace.active-tab {
                display: flex;
            }

            .editor-toolbar {
                overflow-x: auto;
                flex-wrap: nowrap;
                padding-bottom: 5px;
            }

            .toolbar-btn {
                flex-shrink: 0;
                padding: 8px 12px;
                /* Larger touch target */
            }
        }

        /* --- PRINT STYLES --- */
        /* --- PRINT STYLES --- */
        @media print {
            @page {
                margin: 0.5cm;
                size: auto;
            }

            html,
            body {
                background: white;
                height: auto;
                width: 100%;
                margin: 0 !important;
                padding: 0 !important;
                overflow: visible !important;
                position: static !important;
            }

            body * {
                visibility: hidden;
            }

            #recipeModalWrapper,
            #recipeModalWrapper * {
                visibility: visible;
            }

            #recipeModalWrapper {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                margin: 0;
                padding: 0;
                background: white;
                color: black;
                z-index: 9999;
                overflow: visible !important;
            }

            .recipe-modal {
                background: white !important;
                border: none !important;
                box-shadow: none !important;
                width: 100% !important;
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            .modal-header button,
            .modal-header .cyber-btn {
                display: none !important;
            }

            .modal-header {
                display: flex !important;
                justify-content: center !important;
                /* Center the title */
                border-bottom: 1px solid #333 !important;
                padding-bottom: 5px !important;
                margin-bottom: 10px !important;
            }

            .modal-header h2 {
                color: black !important;
                text-align: center !important;
                font-size: 18pt;
                border: none !important;
                /* Remove border from h2 itself if any */
                margin: 0 !important;
                line-height: 1.2;
                width: 100%;
            }

            .modal-body {
                padding: 0 !important;
                font-family: 'Georgia', serif;
                color: #333;
                font-size: 10pt;
                display: block !important;
                /* Reset flex/grid on body itself */
            }

            /* Main Grid Container */
            .modal-content-grid {
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                /* Equal width columns */
                grid-template-rows: auto 1fr;
                gap: 20px;
                align-items: start;
            }

            /* SIDEBAR (Image + Ingredients) */
            .modal-sidebar {
                display: contents !important;
                /* Unwrap sidebar to place children on grid */
            }

            /* 1. Image Area */
            .gallery-container {
                grid-column: 1;
                grid-row: 1;
                margin-bottom: 10px;
                border: none !important;
                /* Remove container border */
                background: transparent !important;
                /* Transparent background */
            }

            .gallery-container img {
                width: 100% !important;
                height: auto !important;
                max-height: 400px;
                /* Allow larger image */
                object-fit: cover !important;
                border-radius: 25px !important;
                /* Increased radius */
                border: none !important;
                /* Remove any border */
                box-shadow: none !important;
                /* Remove any shadow */
            }

            .gallery-thumbs {
                display: none !important;
            }

            /* 2. Ingredients Area (Moved to Right of Image) */
            .modal-sidebar>div:last-child {
                /* The div containing ingredients */
                grid-column: 2;
                grid-row: 1;
                margin-top: 0 !important;
                padding-left: 20px;
                border-left: 1px solid #eee;
            }

            /* Hide serving controls */
            .servings-control {
                display: none !important;
            }

            /* MAIN CONTENT (Instructions) */
            .modal-main {
                grid-column: 1 / -1;
                /* Span full width */
                grid-row: 2;
                margin-top: 20px;
                border-top: 2px solid #eee;
                padding-top: 20px;
            }

            /* Prep/Cook Times */
            .modal-main>div:first-child {
                /* Move times to under the image? Or keep with instructions? */
                /* Let's move them under the image for compactness */
                grid-column: 1;
                grid-row: 1;
                align-self: end;
                font-size: 8pt;
                margin-bottom: -20px !important;
                /* Hack to pull it up if needed, or just let it flow */
                /* Actually, let's just hide them or keep them small at top of instructions */
                display: flex;
                gap: 15px;
                margin-bottom: 10px !important;
                color: #555 !important;
            }

            /* Better approach: Move Prep/Cook to column 1, row 2 (under image) if possible.
               But .modal-main wraps them. So we can't easily move them out without JS.
               Let's just keep them at the start of instructions. */

            h3 {
                color: #000 !important;
                border-bottom: 1px solid #ccc;
                padding-bottom: 2px;
                margin-top: 0;
                margin-bottom: 5px;
                font-size: 12pt;
                text-transform: uppercase;
            }

            ul,
            ol {
                padding-left: 15px;
                margin-top: 0;
            }

            li {
                margin-bottom: 2px;
            }

            .ingredient-item {
                display: flex;
                justify-content: space-between;
                border-bottom: 1px dotted #ccc;
                padding: 2px 0;
            }

            /* Hide non-print elements */
            .sticky-header,
            .sys-bar,
            .toolbar,
            .app-container,
            .load-more-container,
            .toast {
                display: none !important;
            }

        }

        /* --- LIGHTBOX --- */
        #lightboxOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #lightboxOverlay.active {
            display: flex;
        }

        #lightboxImage {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10001;
            background: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 2rem;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 50%;
            z-index: 10001;
            user-select: none;
        }

        .lightbox-prev {
            left: 20px;
        }

        .lightbox-next {
            right: 20px;
        }

        @media (max-width: 768px) {
            .lightbox-nav {
                display: none;
            }

            /* Hide arrows on mobile, rely on swipe */
            #lightboxImage {
                max-height: 70vh;
                width: 95%;
            }
        }

        /* --- SCROLL TO TOP --- */
        #scrollTopBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--neon-blue);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9000;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            font-size: 1.2rem;
        }

        #scrollTopBtn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue);
            transform: translateY(-3px);
        }
    </style>
</head>

<body>

    <div class="sticky-header">
        <!-- SYSTEM BAR -->
        <div class="sys-bar">
            <div class="sys-title">
                <i class="fas fa-microchip"></i> CYBER CHEF
            </div>

            <div class="search-container">
                <input type="text" id="searchInput" class="cyber-input" placeholder="Search  (Title, Tag, Ingr)..."
                    oninput="renderGrid(true); toggleSearchClearBtn()">
                <button id="searchClearBtn" class="search-clear-btn" onclick="clearSearch()"><i
                        class="fas fa-times"></i></button>
            </div>

            <div class="sys-controls">
                <!-- Sort (Moved here for mobile compactness) -->
                <select id="sortSelect" class="cyber-input" style="width:auto; padding:4px 8px;"
                    onchange="renderGrid(true)">
                    <option value="date-desc">Newest (Added)</option>
                    <option value="date-asc">Oldest (Added)</option>
                    <option value="updated-desc">Last Modified</option>
                    <option value="alpha-asc">A-Z</option>
                    <option value="alpha-desc">Z-A</option>
                </select>

                <button class="cyber-btn" id="viewToggleBtn"><i class="fas fa-th"></i> <span
                        class="btn-text">View</span></button>
                <button class="cyber-btn action" onclick="openEditModal()"><i class="fas fa-plus"></i> <span
                        class="btn-text">New</span></button>

                <!-- Mobile Menu Toggle -->
                <button class="cyber-btn" id="mobileMenuBtn" onclick="toggleMobileMenu()"><i
                        class="fas fa-ellipsis-v"></i></button>

                <!-- Secondary Controls (Hidden in menu on mobile) -->
                <div id="secondaryControls">
                    <button class="cyber-btn" onclick="toggleSelectMode()"><i class="fas fa-check-square"></i> <span
                            class="btn-text">Select</span></button>
                    <input type="file" id="fileInput" accept=".json,.paprikarecipes,.paprikarecipe" multiple
                        style="display: none;" onchange="handleFileImport(this)">
                    <button class="cyber-btn" onclick="document.getElementById('fileInput').click()"><i
                            class="fas fa-file-import"></i> <span class="btn-text">Import</span></button>
                    <button class="cyber-btn" onclick="importFromUrl()"><i class="fas fa-globe"></i> <span
                            class="btn-text">URL</span></button>
                    <button class="cyber-btn" onclick="exportData()"><i class="fas fa-file-export"></i> <span
                            class="btn-text">Export</span></button>
                </div>
            </div>
        </div>

        <!-- Toolbar (Moved outside for full width sticky) -->
        <div class="toolbar">
            <div class="toolbar-inner">
                <div class="filters" id="tagFilters">
                    <span class="tag-pill active" onclick="filterByTag('all')">ALL</span>
                    <!-- Dynamic tags here -->
                </div>
                <div class="filters2">
                    <span id="recipeCount" style="color:#666; font-family:var(--code-font); padding-top:5px">0
                        UNITS</span>
                    <button class="cyber-btn danger hidden" id="deleteBtn" onclick="deleteSelected()">DELETE
                        SELECTED</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div class="app-container">

        <!-- Grid -->
        <div class="recipe-grid" id="recipeGrid">
            <!-- Cards rendered via JS -->
        </div>

        <!-- Infinite Scroll Sentinel -->
        <div class="load-more-container" id="scrollSentinel">
            <button class="cyber-btn" id="loadMoreBtn" onclick="loadMore()">Load More Data...</button>
        </div>

    </div>

    <!-- VIEW/EDIT MODAL -->
    <div class="modal-wrapper" id="recipeModalWrapper" onclick="closeModal(event)">
        <div class="recipe-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="modalTitle" style="font-family: var(--cyber-font); color: var(--neon-orange);">RECIPE TITLE</h2>
                <div style="display:flex; gap:10px;">
                    <button class="cyber-btn" onclick="printRecipe()"><i class="fas fa-print"></i></button>
                    <button class="cyber-btn" onclick="editCurrentRecipe()"><i class="fas fa-edit"></i></button>
                    <button class="cyber-btn danger" onclick="closeModalDirect()"><i class="fas fa-times"></i></button>
                </div>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content injected via JS -->
            </div>
        </div>
    </div>

    <!-- EDIT FORM MODAL -->
    <div class="modal-wrapper" id="editModalWrapper" onclick="closeEditModal(event)">
        <div class="recipe-modal" style="width: 95%; height: 90vh; max-width: 1600px;"
            onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2><span style="color:var(--neon-green)">//</span> EDIT RECIPE</h2>
                <button class="cyber-btn danger" onclick="closeEditModalDirect()"><i class="fas fa-times"></i></button>
            </div>

            <div class="modal-body" style="padding: 0; overflow: hidden;">
                <form id="recipeForm" onsubmit="saveRecipe(event)" class="edit-layout-container">
                    <input type="hidden" id="editId">

                    <!-- TOP: TITLE -->
                    <div class="edit-header">
                        <div class="form-group">
                            <label class="form-label">TITLE</label>
                            <input type="text" id="editTitle" class="cyber-input" required
                                style="font-size: 1.1rem; font-weight: bold;">
                        </div>
                        <!-- Mobile Tabs -->
                        <div class="mobile-edit-tabs">
                            <button type="button" class="mobile-tab-btn active"
                                onclick="switchEditTab('details', this)">DETAILS</button>
                            <button type="button" class="mobile-tab-btn"
                                onclick="switchEditTab('steps', this)">INSTRUCTIONS</button>
                        </div>
                    </div>

                    <!-- MAIN GRID -->
                    <div class="edit-main-grid">

                        <!-- LEFT SIDEBAR (Details Tab) -->
                        <div class="edit-sidebar active-tab" id="editTabDetails">
                            <!-- Meta -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div class="form-group">
                                    <label class="form-label">PREP</label>
                                    <input type="text" id="editPrep" class="cyber-input" placeholder="20m">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">COOK</label>
                                    <input type="text" id="editCook" class="cyber-input" placeholder="10m">
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">SERVINGS</label>
                                <input type="number" id="editServings" class="cyber-input" value="4">
                            </div>

                            <!-- Tags -->
                            <div class="form-group">
                                <label class="form-label">TAGS</label>
                                <input type="text" id="editTags" class="cyber-input" placeholder="Tag1, Tag2"
                                    oninput="updateTagSelectionVisuals()">
                                <div id="availableTags" class="tags-selector" style="max-height: 150px;"></div>
                            </div>

                            <!-- Ingredients -->
                            <div class="form-group" style="flex: 1; display: flex; flex-direction: column;">
                                <label class="form-label">INGREDIENTS</label>
                                <textarea id="editIngredients" class="cyber-input"
                                    style="flex: 1; min-height: 200px; resize: none; font-family: var(--code-font); font-size: 0.9rem;"
                                    placeholder="100g Flour"></textarea>
                            </div>

                            <!-- Images -->
                            <div class="form-group">
                                <label class="form-label">PHOTOS</label>
                                <div style="display:flex; gap:5px; margin-bottom:5px;">
                                    <input type="file" id="imageUploadInput" accept="image/*" style="display:none"
                                        multiple onchange="handleImageUpload(this)">
                                    <button type="button" class="cyber-btn"
                                        onclick="document.getElementById('imageUploadInput').click()"
                                        style="width:100%; justify-content:center;">
                                        <i class="fas fa-upload"></i> Upload
                                    </button>
                                </div>
                                <div id="editImagesList" class="edit-image-list"></div>
                            </div>
                        </div>

                        <!-- RIGHT WORKSPACE (Steps Tab) -->
                        <div class="edit-workspace" id="editTabSteps">
                            <!-- Toolbar -->
                            <div class="editor-toolbar">
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('**', '**')"><i class="fas fa-bold"></i></button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('*', '*')"><i class="fas fa-italic"></i></button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('# ', '')">H1</button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('## ', '')">H2</button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('### ', '')">H3</button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('- ', '')"><i class="fas fa-list-ul"></i></button>
                                <button type="button" class="toolbar-btn" onmousedown="event.preventDefault()"
                                    onclick="insertMarkdown('1. ', '')"><i class="fas fa-list-ol"></i></button>
                                <div style="width: 1px; background: #444; margin: 0 5px;"></div>
                                <input type="file" id="stepMediaInput" style="display:none" accept="image/*,video/*"
                                    onchange="handleStepMediaInput(this)">
                                <button type="button" class="cyber-btn" style="padding:2px 8px; font-size:0.7rem;"
                                    onmousedown="event.preventDefault()"
                                    onclick="document.getElementById('stepMediaInput').click()">
                                    <i class="fas fa-paperclip"></i> Media
                                </button>
                            </div>

                            <!-- Single Editor View -->
                            <!-- Single Editor View -->
                            <div id="editSteps" class="rich-editor scrollable" contenteditable="true"
                                onfocus="handleEditorFocus()" onblur="handleEditorBlur()"
                                ondragover="handleMediaDragOver(event)" ondrop="handleMediaDrop(event)"></div>

                            <!-- Save Button Area -->
                            <div style="margin-top: 15px; text-align: right;">
                                <button type="submit" class="cyber-btn action"
                                    style="padding: 10px 30px; font-size: 1rem;">SAVE RECIPE</button>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- LIGHTBOX -->
    <div id="lightboxOverlay" onclick="closeLightbox(event)">
        <div class="lightbox-close" onclick="closeLightbox(event)">&times;</div>
        <div class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1, event)">&#10094;</div>
        <img id="lightboxImage" src="" alt="Full View">
        <div class="lightbox-nav lightbox-next" onclick="navigateLightbox(1, event)">&#10095;</div>
    </div>

    <!-- SCROLL TO TOP BTN -->
    <div id="scrollTopBtn" onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </div>

    <script>
        /* --- STATE MANAGEMENT --- */
        let recipes = [];
        let displayedCount = 0;
        let DISPLAY_LIMIT = 12; // Pagination
        let currentView = 'card'; // 'card' | 'list' | 'big-grid'
        let selectedIds = new Set();
        let isSelectMode = false;
        let currentActiveRecipe = null;
        let currentMultiplier = 1;
        let initialEditSteps = ""; // To track changes for deletion
        let initialEditTitle = ""; // To track title changes for folder rename
        let currentRawMarkdown = ""; // To store markdown state for preview toggle
        let draggedMediaElement = null; // For drag and drop logic

        // INDEXED DB CONFIG
        const DB_NAME = 'CyberChefDB';
        const DB_VERSION = 1;
        const RECIPE_STORE = 'recipes_store';
        let db = null;

        // Mock Data for Demo
        const mockData = [
            {
                id: '1',
                title: 'Neon Spicy Ramen',
                prepTime: '20m',
                cookTime: '4h',
                servings: 2,
                tags: ['Dinner', 'Spicy', 'Japanese'],
                images: ['https://images.unsplash.com/photo-1569718212165-3a8278d5f624?w=800', 'https://images.unsplash.com/photo-1555126634-323283e090fa?w=800'],
                ingredients: [
                    { raw: "2 packs ramen noodles", qty: 2, unit: "packs", name: "ramen noodles" },
                    { raw: "500ml bone broth", qty: 500, unit: "ml", name: "bone broth" },
                    { raw: "2 tbsp chili oil", qty: 2, unit: "tbsp", name: "chili oil" },
                    { raw: "1 soft boiled egg", qty: 1, unit: "", name: "soft boiled egg" }
                ],
                steps: "# Broth Preparation\nSimmer bones for 4 hours.\n\n# Assembly\n1. Boil noodles for 3 mins.\n2. Pour hot broth.\n3. Add toppings."
            },
            {
                id: '2',
                title: 'Cyber Burger',
                prepTime: '15m',
                cookTime: '10m',
                servings: 1,
                tags: ['Lunch', 'Fast Food', 'American'],
                images: ['https://images.unsplash.com/photo-1568901346375-23c9450c58cd?w=800'],
                ingredients: [
                    { raw: "1 beef patty", qty: 1, unit: "", name: "beef patty" },
                    { raw: "1 brioche bun", qty: 1, unit: "", name: "brioche bun" },
                    { raw: "1 slice cheese", qty: 1, unit: "slice", name: "cheese" }
                ],
                steps: "Grill patty. Melt cheese. Toast bun. Assemble."
            }
        ];

        /* --- INITIALIZATION --- */
        window.onload = async function () {
            // Configure marked for line breaks
            if (typeof marked !== 'undefined') {
                marked.setOptions({ breaks: true });
            }

            await initDB();
            await loadData();
            // await loadFromDirectory(); // Deprecated: Server handles loading
            setupEventListeners();
            setupInfiniteScroll(); // Activate Infinite Scroll
            renderTags();
            renderGrid();
        };

        /* --- INFINITE SCROLL --- */
        function setupInfiniteScroll() {
            const observer = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                    // Only load more if the button is visible (meaning there is data to load)
                    const btn = document.getElementById('loadMoreBtn');
                    if (btn && btn.style.display !== 'none') {
                        loadMore();
                    }
                }
            }, {
                root: null, // viewport
                rootMargin: '100px', // Trigger 100px before bottom
                threshold: 0.1
            });

            const sentinel = document.getElementById('scrollSentinel');
            if (sentinel) observer.observe(sentinel);
        }

        /* --- INDEXED DB HELPERS --- */
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(RECIPE_STORE)) {
                        db.createObjectStore(RECIPE_STORE, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };

                request.onerror = (e) => {
                    console.error("IDB Error", e);
                    reject(e);
                };
            });
        }

        async function loadData() {
            try {
                const res = await fetch('/api/recipes');
                if (res.ok) {
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                        recipes = data;
                        console.log("Loaded from Server:", recipes.length);
                    } else {
                        console.log("Server empty, using mock/local");
                        // Fallback logic if needed, or just keep empty
                        if (recipes.length === 0) recipes = mockData;
                    }
                } else {
                    throw new Error("Server API Error");
                }
            } catch (e) {
                console.warn("Server not reachable, using LocalStorage/Mock", e);
                const lsData = localStorage.getItem('recipes_db');
                if (lsData) recipes = JSON.parse(lsData);
                else recipes = mockData;
            }

            // Sort by title
            recipes.sort((a, b) => a.title.localeCompare(b.title));
        }

        async function saveData() {
            // 1. Save to Server (Primary)
            try {
                const res = await fetch('/api/recipes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(recipes)
                });
                if (res.ok) {
                    showToast("Saved to Disk (Server)");
                } else {
                    throw new Error("Server Write Failed");
                }
            } catch (e) {
                console.error("Server Save Failed", e);
                showToast("Save Failed (Check Server)");
            }

            // 2. Mirror to LocalStorage (Backup)
            try {
                localStorage.setItem('recipes_db', JSON.stringify(recipes));
            } catch (e) { }
        }

        function showToast(msg) {
            let toast = document.getElementById('toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast';
                toast.className = 'toast';
                document.body.appendChild(toast);
            }
            toast.innerText = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        /* --- AUTO-IMPORT FROM ./recipes/recipes.json --- */
        async function loadFromDirectory() {
            console.log("Attempting to auto-import from ./recipes/recipes.json...");
            try {
                // Use relative path - safer for local structures
                const res = await fetch('./recipes/recipes.json');

                if (!res.ok) {
                    console.warn(`Auto-import failed: HTTP ${res.status} - ${res.statusText}`);
                    return;
                }

                const data = await res.json();
                console.log("File found, parsing data...", data);

                let importedRecipes = [];

                if (Array.isArray(data)) {
                    importedRecipes = data;
                } else if (data.recipes && Array.isArray(data.recipes)) {
                    importedRecipes = data.recipes;
                }

                if (importedRecipes.length > 0) {
                    let count = 0;
                    importedRecipes.forEach(r => {
                        const normalized = mapPaprikaToApp(r);

                        // Check existence to avoid duplicate ID issues
                        const exists = recipes.find(ex => ex.id === normalized.id);
                        if (!exists) {
                            recipes.push(normalized);
                            count++;
                        }
                    });

                    if (count > 0) {
                        await saveData();
                        console.log(`Success: Auto-imported ${count} recipes.`);
                        // Force refresh grid if new data came in
                        renderGrid();
                        renderTags();
                    } else {
                        console.log("File loaded but no new recipes found or duplicate IDs.");
                    }
                }
            } catch (e) {
                console.error("Auto-import error or file not found:", e);
            }
        }

        function setupEventListeners() {
            document.getElementById('searchInput').addEventListener('input', (e) => {
                displayedCount = 0; // Reset pagination
                renderGrid(e.target.value);
            });

            // View Toggle Logic: Card -> List -> Big Grid -> Card
            document.getElementById('viewToggleBtn').addEventListener('click', () => {
                const btn = document.getElementById('viewToggleBtn');
                const grid = document.getElementById('recipeGrid');

                if (currentView === 'card') {
                    currentView = 'list';
                    grid.className = 'recipe-grid list-view';
                    btn.innerHTML = '<i class="fas fa-list"></i>';
                } else if (currentView === 'list') {
                    currentView = 'big-grid';
                    grid.className = 'recipe-grid big-grid-view';
                    btn.innerHTML = '<i class="fas fa-square"></i>';
                } else {
                    currentView = 'card';
                    grid.className = 'recipe-grid';
                    btn.innerHTML = '<i class="fas fa-th"></i>';
                }
            });

            // Scroll To Top Visibility
            window.addEventListener('scroll', () => {
                const btn = document.getElementById('scrollTopBtn');
                if (window.scrollY > 300) {
                    btn.style.display = 'flex';
                } else {
                    btn.style.display = 'none';
                }
            });
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        /* --- PARSING & LOGIC --- */

        function parseIngredient(line) {
            line = line.trim();
            // 1. Extract Quantity (fractions, decimals, ranges)
            // Matches: "1", "1.5", "1/2", "1-2"
            const qtyRegex = /^([\d\.,\/]+(?:\s*-\s*[\d\.,\/]+)?)\s*(.*)$/;
            const match = line.match(qtyRegex);

            if (!match) {
                return { raw: line, qty: 0, unit: "", name: line };
            }

            let qtyStr = match[1].replace(',', '.'); // Normalize decimal
            let rest = match[2];
            let qty = 0;

            // Try to parse quantity
            try {
                if (qtyStr.includes('/')) {
                    const [n, d] = qtyStr.split('/');
                    qty = parseFloat(n) / parseFloat(d);
                } else if (qtyStr.includes('-')) {
                    qty = parseFloat(qtyStr.split('-')[0]);
                } else {
                    qty = parseFloat(qtyStr);
                }
            } catch (e) { qty = 0; }
            if (isNaN(qty)) qty = 0;

            // 2. Extract Unit
            // Common French units
            const units = [
                'g', 'gr', 'gramme', 'grammes', 'kg', 'kilogramme', 'kilogrammes',
                'ml', 'cl', 'dl', 'l', 'litre', 'litres',
                'c. à s.', 'c.à.s.', 'c.à.s', 'cas', 'cuillère à soupe', 'cuillères à soupe',
                'c. à c.', 'c.à.c.', 'c.à.c', 'cac', 'cuillère à café', 'cuillères à café',
                'pincée', 'pincées',
                'gousse', 'gousses',
                'bouquet', 'bouquets',
                'botte', 'bottes',
                'branche', 'branches',
                'verre', 'verres',
                'tasse', 'tasses',
                'bol', 'bols',
                'tranche', 'tranches',
                'filet', 'filets',
                'poignée', 'poignées',
                'feuille', 'feuilles',
                'brin', 'brins',
                'tête', 'têtes',
                'zeste', 'zestes',
                'pot', 'pots'
            ];

            // Sort units by length descending to match longest first
            units.sort((a, b) => b.length - a.length);

            let unit = "";
            let name = rest;

            for (let u of units) {
                // Check if rest starts with unit (case insensitive)
                if (rest.toLowerCase().startsWith(u.toLowerCase())) {
                    // Check boundary: next char must be space, dot, or end of string
                    // But 'c.à.s' ends with dot, so we just check if we matched the whole unit string
                    // and the next char is space or empty.
                    const nextChar = rest[u.length];
                    if (!nextChar || nextChar === ' ' || nextChar === '.') {
                        unit = u;
                        name = rest.substring(u.length).trim();
                        break;
                    }
                }
            }

            // 3. Clean Name (remove "de", "d'")
            // "de " or "d'" at start
            const prefixRegex = /^(de\s+|d'|du\s+|des\s+)/i;
            name = name.replace(prefixRegex, '');

            return { raw: line, qty: qty, unit: unit, name: name };
        }

        /* --- RENDERING --- */

        function renderTags() {
            const allTags = new Set();
            recipes.forEach(r => r.tags.forEach(t => allTags.add(t)));
            const container = document.getElementById('tagFilters');

            // Add Favorite Filter
            let html = `
                <span class="tag-pill active" onclick="filterByTag('all', this)">ALL</span>
                <span class="tag-pill" onclick="filterByTag('favorites', this)"><i class="fas fa-heart" style="color:var(--neon-red)"></i></span>
            `;

            Array.from(allTags).sort().forEach(tag => {
                html += `<span class="tag-pill" onclick="filterByTag('${tag}', this)">${tag.toUpperCase()}</span>`;
            });
            container.innerHTML = html;
        }

        let currentTagFilter = 'all';

        function filterByTag(tag, el) {
            currentTagFilter = tag;
            displayedCount = 0;
            if (el) {
                document.querySelectorAll('.tag-pill').forEach(p => p.classList.remove('active'));
                el.classList.add('active');
            }
            renderGrid(true); // Always reset grid when changing filter
        }

        let currentFilteredRecipes = [];
        // Slideshow management via IntersectionObserver
        const slideshowMap = new Map(); // Map card element -> { interval, currentIdx, images, imgElements, indicator }

        const slideshowObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const card = entry.target;
                if (entry.isIntersecting) {
                    startSlideshow(card);
                } else {
                    stopSlideshow(card);
                }
            });
        }, { threshold: 0.5 }); // 50% visible to start

        function startSlideshow(card) {
            if (!slideshowMap.has(card)) return;
            const data = slideshowMap.get(card);
            if (data.interval) return; // Already running

            data.interval = setInterval(() => {
                data.currentIdx = (data.currentIdx + 1) % data.images.length;
                updateCardImage(data);
            }, 3000);
        }

        function stopSlideshow(card) {
            if (!slideshowMap.has(card)) return;
            const data = slideshowMap.get(card);
            if (data.interval) {
                clearInterval(data.interval);
                data.interval = null;
            }
        }

        function updateCardImage(data) {
            data.imgElements.forEach((img, i) => {
                img.style.opacity = i === data.currentIdx ? '1' : '0';
            });
            if (data.indicator) data.indicator.innerText = `${data.currentIdx + 1}/${data.images.length}`;
        }

        function renderGrid(reset = false, customLimit = null) {
            // Clear existing slideshows and observer
            slideshowObserver.disconnect();
            slideshowMap.forEach(data => {
                if (data.interval) clearInterval(data.interval);
            });
            slideshowMap.clear();

            const grid = document.getElementById('recipeGrid');
            const loadBtn = document.getElementById('loadMoreBtn');
            const searchTerm = document.getElementById('searchInput').value;

            // If reset, clear everything
            if (reset) {
                displayedCount = 0;
                grid.innerHTML = '';
            }

            // Filter
            let filtered = recipes.filter(r => {
                const matchSearch = r.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    r.tags.some(t => t.toLowerCase().includes(searchTerm.toLowerCase())) ||
                    r.ingredients.some(i => i.name.toLowerCase().includes(searchTerm.toLowerCase()));

                // Use currentTagFilter state instead of DOM innerText
                let matchTag = true;
                if (currentTagFilter === 'favorites') {
                    matchTag = r.favorite === true;
                } else {
                    matchTag = currentTagFilter === 'all' || r.tags.includes(currentTagFilter);
                }

                return matchSearch && matchTag;
            });

            // Sort
            const sortMode = document.getElementById('sortSelect').value;
            filtered.sort((a, b) => {
                if (sortMode === 'alpha-asc') return a.title.localeCompare(b.title);
                if (sortMode === 'alpha-desc') return b.title.localeCompare(a.title);

                if (sortMode === 'updated-desc') {
                    const dateA = a.updatedAt || a.createdAt || 0;
                    const dateB = b.updatedAt || b.createdAt || 0;
                    return dateB - dateA;
                }

                const dateA = a.createdAt || 0;
                const dateB = b.createdAt || 0;

                if (dateA !== dateB) {
                    return sortMode === 'date-asc' ? dateA - dateB : dateB - dateA;
                } else {
                    const idxA = recipes.indexOf(a);
                    const idxB = recipes.indexOf(b);
                    return sortMode === 'date-asc' ? idxA - idxB : idxB - idxA;
                }
            });

            document.getElementById('recipeCount').innerText = `${filtered.length} UNITS FOUND`;
            currentFilteredRecipes = filtered;

            // Pagination
            const total = filtered.length;
            // If searching, maybe show more? No, keep infinite scroll.
            const limit = customLimit || DISPLAY_LIMIT || 20;

            const toShow = displayedCount + limit;
            const slice = filtered.slice(displayedCount, toShow);

            slice.forEach(recipe => {
                const card = createCard(recipe);
                grid.appendChild(card);
            });

            displayedCount += slice.length;

            if (displayedCount >= total) {
                loadBtn.style.display = 'none';
            } else {
                loadBtn.style.display = 'inline-block';
            }
        }

        function loadMore() {
            renderGrid(false);
        }

        function createCard(recipe) {
            const div = document.createElement('div');
            div.className = `recipe-card ${selectedIds.has(recipe.id) ? 'selected' : ''}`;

            const images = recipe.images && recipe.images.length > 0 ? recipe.images : ['https://placehold.co/400x300/111/FFF?text=No+Image'];
            const imgCount = images.length;
            const hasMultiImages = imgCount > 1;

            // Generate HTML for all images
            const imagesHtml = images.map((src, i) => `
                <img src="${src}" class="card-img" 
                     style="opacity: ${i === 0 ? 1 : 0}; position: absolute; top: 0; left: 0; transition: opacity 0.8s ease;" 
                     data-index="${i}"
                     onerror="this.src='https://placehold.co/400x300/111/FFF?text=Err'">
            `).join('');

            div.innerHTML = `
                <input type="checkbox" class="select-check" ${selectedIds.has(recipe.id) ? 'checked' : ''}>
                <div class="card-img-container" data-id="${recipe.id}">
                    ${imagesHtml}
                    ${hasMultiImages ? `<div class="card-img-indicator">1/${imgCount}</div>` : ''}
                    <button class="fav-btn ${recipe.favorite ? 'active' : ''}" onclick="toggleFavorite('${recipe.id}', event)">
                        <i class="${recipe.favorite ? 'fas' : 'far'} fa-heart"></i>
                    </button>
                </div>
                <div class="card-content">
                    <h3 class="card-title">${recipe.title}</h3>

                    <div class="card-tags">
                        ${recipe.tags.slice(0, 3).map(t => `<span class="mini-tag">${t}</span>`).join('')}
                        ${recipe.tags.length > 3 ? '<span class="mini-tag">...</span>' : ''}
                    </div>
                </div>
            `;

            // --- SWIPE & SLIDESHOW LOGIC ---
            if (hasMultiImages) {
                const container = div.querySelector('.card-img-container');
                const indicator = div.querySelector('.card-img-indicator');
                const imgElements = container.querySelectorAll('.card-img');

                // Register for slideshow
                slideshowMap.set(div, {
                    interval: null,
                    currentIdx: 0,
                    images: images,
                    imgElements: imgElements,
                    indicator: indicator
                });
                slideshowObserver.observe(div);

                // Swipe Logic
                let startX = 0;

                // Touch events
                container.addEventListener('touchstart', e => {
                    startX = e.touches[0].clientX;
                }, { passive: true });

                container.addEventListener('touchend', e => {
                    const endX = e.changedTouches[0].clientX;
                    handleSwipe(startX, endX);
                }, { passive: true });

                // Mouse events
                container.addEventListener('mousedown', e => {
                    startX = e.clientX;
                    e.preventDefault();
                });

                container.addEventListener('mouseup', e => {
                    const endX = e.clientX;
                    handleSwipe(startX, endX);
                });

                function handleSwipe(start, end) {
                    const diff = start - end;
                    if (Math.abs(diff) > 50) {
                        const data = slideshowMap.get(div);
                        if (!data) return;

                        // Reset interval on manual interaction
                        stopSlideshow(div);

                        if (diff > 0) { // Swipe Left -> Next
                            data.currentIdx = (data.currentIdx + 1) % imgCount;
                        } else { // Swipe Right -> Prev
                            data.currentIdx = (data.currentIdx - 1 + imgCount) % imgCount;
                        }
                        updateCardImage(data);

                        // Restart slideshow
                        startSlideshow(div);
                    }
                }

                // Prevent click bubbling
                container.addEventListener('click', e => e.stopPropagation());
            }

            // Click event for card (open modal)
            div.addEventListener('click', (e) => handleCardClick(e, recipe.id));

            return div;
        }

        /* --- INTERACTION --- */

        function handleCardClick(e, id) {
            // Check if user clicked checkbox or is in select mode
            if (isSelectMode || e.target.classList.contains('select-check')) {
                const checkbox = e.currentTarget.querySelector('.select-check');
                // If not in select mode but checkbox clicked, toggle specific card
                if (!isSelectMode && e.target.classList.contains('select-check')) {
                    if (checkbox.checked) selectedIds.add(id);
                    else selectedIds.delete(id);
                } else {
                    // In select mode, toggle selection regardless of where clicked (except swipe area)
                    if (selectedIds.has(id)) selectedIds.delete(id);
                    else selectedIds.add(id);
                }

                // Re-render only to update UI classes if needed, or just toggle class manually
                const card = e.currentTarget;
                if (selectedIds.has(id)) {
                    card.classList.add('selected');
                    card.querySelector('.select-check').checked = true;
                } else {
                    card.classList.remove('selected');
                    card.querySelector('.select-check').checked = false;
                }
                return;
            }

            // If swiping on image, don't open modal (handled by stopPropagation in swipe handler)

            // Open Details
            openModal(id);
        }

        async function toggleFavorite(id, event) {
            event.stopPropagation(); // Prevent card click
            const recipe = recipes.find(r => r.id === id);
            if (recipe) {
                // 1. Optimistic Update (Immediate UI change)
                recipe.favorite = !recipe.favorite;

                // Update UI immediately
                if (currentTagFilter === 'favorites') {
                    // If we are in the favorites list and we un-favorite, it should disappear
                    // But maybe we want a small delay or just let it vanish? 
                    // Let's just re-render to be correct.
                    renderGrid();
                } else {
                    // Just update the button icon instantly
                    const btn = event.currentTarget;
                    if (recipe.favorite) {
                        btn.classList.add('active');
                        btn.querySelector('i').className = 'fas fa-heart';
                    } else {
                        btn.classList.remove('active');
                        btn.querySelector('i').className = 'far fa-heart';
                    }
                }

                // 2. Save in background
                await saveData();
            }
        }

        function printRecipe() {
            window.print();
        }

        function toggleSelectMode() {
            isSelectMode = !isSelectMode;
            document.body.classList.toggle('select-mode');
            document.getElementById('deleteBtn').classList.toggle('hidden');
            if (!isSelectMode) {
                selectedIds.clear();
                renderGrid(document.getElementById('searchInput').value);
            } else {
                // Just show checkboxes
                document.querySelectorAll('.select-check').forEach(c => c.style.display = 'block');
            }
        }

        /* --- MODAL LOGIC --- */

        function openModal(id) {
            currentActiveRecipe = recipes.find(r => r.id === id);
            currentMultiplier = 1;
            if (!currentActiveRecipe) return;

            document.body.classList.add('modal-open');
            document.body.classList.add('no-scroll'); // Disable background scroll
            const wrapper = document.getElementById('recipeModalWrapper');
            const title = document.getElementById('modalTitle');

            title.innerText = currentActiveRecipe.title.toUpperCase();
            renderModalContent();
            wrapper.classList.add('active');
        }

        function renderModalContent() {
            if (!currentActiveRecipe) return;
            const r = currentActiveRecipe;
            const body = document.getElementById('modalBody');

            const mainImg = (r.images && r.images.length > 0) ? r.images[0] : 'https://placehold.co/600x400/111/FFF?text=No+Data';
            let thumbsHtml = '';
            if (r.images && r.images.length > 1) {
                thumbsHtml = r.images.map((src, idx) =>
                    `<img src="${src}" class="thumb ${idx === 0 ? 'active' : ''}" onclick="swapImage(this, '${src}')">`
                ).join('');
            }

            const currentServings = Math.round(r.servings * currentMultiplier);
            const ingredientsHtml = r.ingredients.map(ing => {
                let displayQty = ing.qty ? Math.round((ing.qty * currentMultiplier) * 100) / 100 : '';
                return `
                <li class="ingredient-item">
                    <span>${ing.name}</span>
                    <span class="ing-qty">${displayQty} ${ing.unit}</span>
                </li>`;
            }).join('');

            const stepsHtml = marked.parse(r.steps || '*No instructions provided.*');

            body.innerHTML = `
                <div class="modal-content-grid">
                    <div class="modal-sidebar">
                        <div class="gallery-container">
                            <img src="${mainImg}" id="modalMainImage" class="main-photo" onclick="openLightbox()">
                        </div>
                        <div class="gallery-thumbs">
                            ${thumbsHtml}
                        </div>

                        <div style="margin-top:20px;">
                            <h3 style="color:var(--neon-blue); font-family:var(--cyber-font);">INGREDIENTS</h3>
                            <div class="servings-control">
                                <button class="servings-btn" onclick="updateServings(-0.5)">-</button>
                                <i class="fas fa-users" style="color:#666"></i>
                                <span class="servings-val" id="servingsDisplay">${currentServings}</span>
                                <button class="servings-btn" onclick="updateServings(0.5)">+</button>
                            </div>
                            <ul class="ingredient-list">
                                ${ingredientsHtml}
                            </ul>
                        </div>
                    </div>
                    <div class="modal-main">
                        <div style="display:flex; gap:20px; margin-bottom:20px; color:#888; font-family:var(--code-font);">
                            <span><i class="fas fa-clock"></i> Prep: ${r.prepTime}</span>
                            <span><i class="fas fa-fire"></i> Cook: ${r.cookTime}</span>
                        </div>
                        <div class="instructions-content">
                            ${stepsHtml}
                        </div>
                    </div>
                </div>
            `;
        }

        function swapImage(thumb, src) {
            document.getElementById('modalMainImage').src = src;
            document.querySelectorAll('.thumb').forEach(t => t.classList.remove('active'));
            thumb.classList.add('active');
        }

        function updateServings(delta) {
            const newMultiplier = currentMultiplier + (delta / currentActiveRecipe.servings);
            if (newMultiplier > 0.1) {
                currentMultiplier = newMultiplier;
                renderModalContent();
            }
        }

        function closeModal(e) {
            if (e.target.id === 'recipeModalWrapper') {
                document.getElementById('recipeModalWrapper').classList.remove('active');
                document.body.classList.remove('modal-open');
                document.body.classList.remove('no-scroll'); // Re-enable scroll
                currentActiveRecipe = null;
            }
        }

        function closeModalDirect() {
            document.getElementById('recipeModalWrapper').classList.remove('active');
            document.body.classList.remove('modal-open');
            document.body.classList.remove('no-scroll'); // Re-enable scroll
            currentActiveRecipe = null;
        }

        /* --- CRUD OPERATIONS --- */
        function editCurrentRecipe() {
            const recipeToEdit = currentActiveRecipe;
            closeModalDirect();
            openEditModal(recipeToEdit);
        }

        function openEditModal(recipe = null) {
            const modal = document.getElementById('editModalWrapper');
            const form = document.getElementById('recipeForm');
            const editStepsElement = document.getElementById('editSteps');

            // Clear any preview mode class when opening the editor
            editStepsElement.classList.remove('preview-mode');

            if (recipe) {
                document.getElementById('editId').value = recipe.id;
                document.getElementById('editTitle').value = recipe.title;
                document.getElementById('editPrep').value = recipe.prepTime;
                document.getElementById('editCook').value = recipe.cookTime;
                document.getElementById('editServings').value = recipe.servings;
                document.getElementById('editTags').value = recipe.tags.join(', ');
                document.getElementById('editIngredients').value = recipe.ingredients.map(i => i.raw).join('\n');

                // Convert Markdown to Editor HTML
                currentRawMarkdown = recipe.steps || "";
                editStepsElement.innerHTML = markdownToEditorHtml(currentRawMarkdown);

                initialEditSteps = recipe.steps || ""; // Store initial state
                initialEditTitle = recipe.title || ""; // Store initial title

                const imgList = document.getElementById('editImagesList');
                imgList.innerHTML = '';
                if (recipe.images && Array.isArray(recipe.images)) {
                    recipe.images.forEach(src => addImageToEditList(src));
                }
            } else {
                form.reset();
                document.getElementById('editId').value = '';
                document.getElementById('editImagesList').innerHTML = '';
                editStepsElement.innerHTML = '';
                initialEditSteps = "";
                initialEditTitle = "";
                currentRawMarkdown = ""; // Initialize for new recipe
            }
            modal.classList.add('active');

            // Reset Mobile Tab to Details
            if (window.innerWidth <= 900) {
                switchEditTab('details', document.querySelector('.mobile-tab-btn'));
            }

            renderAvailableTags();
        }

        function renderAvailableTags() {
            const container = document.getElementById('availableTags');
            container.innerHTML = '';

            // Collect all unique tags from all recipes
            const allTags = new Set();
            recipes.forEach(r => {
                if (r.tags) r.tags.forEach(t => allTags.add(t));
            });

            // Sort them
            const sortedTags = Array.from(allTags).sort();

            if (sortedTags.length === 0) {
                container.innerHTML = '<span style="color:#666; font-size:0.8rem;">No existing tags found. Type above to create new ones.</span>';
                return;
            }

            sortedTags.forEach(tag => {
                const span = document.createElement('span');
                span.className = 'tag-pill selectable';
                span.innerText = tag;
                span.onclick = () => toggleEditTag(tag);
                container.appendChild(span);
            });

            updateTagSelectionVisuals();
        }

        function toggleEditTag(tag) {
            const input = document.getElementById('editTags');
            let currentTags = input.value.split(',').map(t => t.trim()).filter(t => t);

            if (currentTags.includes(tag)) {
                // Remove
                currentTags = currentTags.filter(t => t !== tag);
            } else {
                // Add
                currentTags.push(tag);
            }

            input.value = currentTags.join(', ');
            updateTagSelectionVisuals();
        }

        function updateTagSelectionVisuals() {
            const input = document.getElementById('editTags');
            const currentTags = new Set(input.value.split(',').map(t => t.trim()));

            const pills = document.querySelectorAll('#availableTags .tag-pill');
            pills.forEach(pill => {
                if (currentTags.has(pill.innerText)) {
                    pill.classList.add('selected');
                } else {
                    pill.classList.remove('selected');
                }
            });
        }

        function addImageToEditList(src) {
            const div = document.createElement('div');
            div.className = 'edit-image-item';
            div.draggable = true; // Enable drag
            div.innerHTML = `
                <img src="${src}">
                <button type="button" class="edit-image-remove" onclick="this.parentElement.remove()">X</button>
            `;

            // Drag Events
            div.addEventListener('dragstart', () => {
                div.classList.add('dragging');
            });

            div.addEventListener('dragend', () => {
                div.classList.remove('dragging');
            });

            // Allow dropping on other items to reorder
            const list = document.getElementById('editImagesList');
            list.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(list, e.clientX, e.clientY);
                const draggable = document.querySelector('.dragging');
                if (afterElement == null) {
                    list.appendChild(draggable);
                } else {
                    list.insertBefore(draggable, afterElement);
                }
            });

            document.getElementById('editImagesList').appendChild(div);
        }

        // Helper to find position
        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.edit-image-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                // Calculate distance from center of box
                // We use both X and Y because it's a flex-wrap list
                const offsetX = x - (box.left + box.width / 2);
                const offsetY = y - (box.top + box.height / 2);

                // Simple distance check might be better, or just checking if we are "before" the center
                // Since it's a grid, strict "after" logic is tricky. 
                // Let's try a simple distance metric to find the closest element

                const dist = Math.hypot(offsetX, offsetY);

                if (closest == null || dist < closest.dist) {
                    return { offset: dist, element: child, dist: dist };
                } else {
                    return closest;
                }
            }, null).element;
        }

        function closeEditModal(e) {
            if (e.target.id === 'editModalWrapper') closeEditModalDirect();
        }

        function closeEditModalDirect() {
            document.getElementById('editModalWrapper').classList.remove('active');
        }

        async function saveRecipe(e) {
            e.preventDefault();
            const id = document.getElementById('editId').value || crypto.randomUUID();
            const title = document.getElementById('editTitle').value;
            const prep = document.getElementById('editPrep').value;
            const cook = document.getElementById('editCook').value;
            const serv = parseFloat(document.getElementById('editServings').value) || 2;
            const tags = document.getElementById('editTags').value.split(',').map(t => t.trim()).filter(t => t);
            const rawIng = document.getElementById('editIngredients').value.split('\n');
            const ingredients = rawIng.filter(l => l.trim()).map(parseIngredient);

            // Convert Editor HTML back to Markdown
            let steps = "";
            const editor = document.getElementById('editSteps');

            // Check if in preview mode (class added on blur)
            if (editor.classList.contains('preview-mode')) {
                steps = currentRawMarkdown;
            } else {
                steps = editorHtmlToMarkdown(editor.innerHTML);
            }

            // Get images from list
            let images = Array.from(document.querySelectorAll('#editImagesList img')).map(img => img.getAttribute('src'));

            // Handle Folder Rename if Title Changed
            if (initialEditTitle && initialEditTitle !== title) {
                const oldFolder = initialEditTitle.trim().replace(/[^a-z0-9\-_]/gi, '_');
                const newFolder = title.trim().replace(/[^a-z0-9\-_]/gi, '_');

                if (oldFolder !== newFolder) {
                    const oldPath = '/recipes/medias/' + oldFolder;
                    const newPath = '/recipes/medias/' + newFolder;

                    console.log(`Renaming folder: ${oldPath} -> ${newPath}`);
                    try {
                        const res = await fetch('/api/rename-folder', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ oldPath, newPath })
                        });

                        if (res.ok) {
                            // Update paths in images array
                            images = images.map(img => img.replace(oldPath, newPath));
                            // Update paths in steps
                            steps = steps.split(oldPath).join(newPath);
                            showToast("Folder renamed successfully");
                        }
                    } catch (e) {
                        console.error("Rename failed", e);
                        alert("Failed to rename media folder. Check console.");
                    }
                }
            }

            const existingRecipe = recipes.find(r => r.id === id);
            const isFavorite = existingRecipe ? !!existingRecipe.favorite : false;

            const newRecipe = {
                id, title, prepTime: prep, cookTime: cook, servings: serv, tags, ingredients, steps, images,
                favorite: isFavorite, // Preserve favorite status
                createdAt: (existingRecipe ? (existingRecipe.createdAt || Date.now()) : Date.now()),
                updatedAt: Date.now() // Always update modification time
            };

            const index = recipes.findIndex(r => r.id === id);
            if (index >= 0) recipes[index] = newRecipe;
            else recipes.push(newRecipe);

            // Cleanup orphaned media
            await cleanupOrphanedMedia(initialEditSteps, steps);

            // Capture state before reset
            const scrollPos = window.scrollY;
            const countToRestore = Math.max(displayedCount, 20);

            await saveData();
            closeEditModalDirect();

            renderGrid(true, countToRestore); // Force reset but restore count

            // Restore scroll
            window.scrollTo(0, scrollPos);
        }

        async function cleanupOrphanedMedia(oldText, newText) {
            if (!oldText) return;

            const extractUrls = (text) => {
                const urls = new Set();
                // Markdown images: ![alt](url)
                const imgRegex = /!\[.*?\]\((.*?)\)/g;
                let match;
                while ((match = imgRegex.exec(text)) !== null) {
                    urls.add(match[1]);
                }
                // HTML videos: src="url"
                const vidRegex = /src=["'](.*?)["']/g;
                while ((match = vidRegex.exec(text)) !== null) {
                    urls.add(match[1]);
                }
                return urls;
            };

            const oldUrls = extractUrls(oldText);
            const newUrls = extractUrls(newText);

            for (let url of oldUrls) {
                // If url was in old text but NOT in new text, and it looks like a local file
                if (!newUrls.has(url) && url.startsWith('/recipes/medias/')) {
                    console.log("Deleting orphaned file:", url);
                    try {
                        await fetch('/api/file', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: url })
                        });
                    } catch (e) {
                        console.error("Failed to delete orphaned file", e);
                    }
                }
            }
        }

        async function handleImageUpload(input) {
            if (!input.files || input.files.length === 0) return;

            const title = document.getElementById('editTitle').value || 'Untitled';
            // Sanitize folder name
            const folder = title.trim().replace(/[^a-z0-9\-_]/gi, '_');

            for (let i = 0; i < input.files.length; i++) {
                try {
                    const path = await uploadImage(input.files[i], folder);
                    addImageToEditList(path);
                } catch (e) {
                    console.error(e);
                    alert("Upload failed for " + input.files[i].name);
                }
            }
            input.value = ''; // Reset
        }

        /* --- STEPS MEDIA HANDLING --- */

        // Handle Paste on Div
        document.getElementById('editSteps').addEventListener('paste', async (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let hasFile = false;
            for (let index in items) {
                const item = items[index];
                if (item.kind === 'file') {
                    e.preventDefault();
                    hasFile = true;
                    const blob = item.getAsFile();
                    await uploadAndInsertMedia(blob);
                }
            }
            // If text paste, let default handle it or strip formatting if needed
        });

        async function handleStepMediaInput(input) {
            if (input.files && input.files[0]) {
                await uploadAndInsertMedia(input.files[0]);
                input.value = '';
            }
        }

        async function uploadAndInsertMedia(file) {
            const title = document.getElementById('editTitle').value || 'Untitled';
            const baseFolder = title.trim().replace(/[^a-z0-9\-_]/gi, '_');
            const folder = baseFolder + '/steps_media';

            showToast("Uploading media...");
            try {
                const path = await uploadImage(file, folder);
                insertMediaToEditor(path, file.type);
                showToast("Media Inserted!");
            } catch (e) {
                console.error(e);
                alert("Upload failed");
            }
        }

        function insertMediaToEditor(path, type) {
            const editor = document.getElementById('editSteps');
            editor.focus();

            const wrapper = document.createElement('span');
            wrapper.className = 'media-wrapper';
            wrapper.contentEditable = false; // Make it a block
            wrapper.draggable = true;

            // Drag Start Listener
            wrapper.addEventListener('dragstart', (e) => {
                draggedMediaElement = wrapper;
                e.dataTransfer.effectAllowed = 'move';
            });

            const delBtn = document.createElement('button');
            delBtn.className = 'media-delete';
            delBtn.innerText = 'x';
            delBtn.onclick = function () { wrapper.remove(); };

            let mediaEl;
            if (type && type.startsWith('video/')) {
                mediaEl = document.createElement('video');
                mediaEl.src = path;
                mediaEl.controls = true;
            } else {
                mediaEl = document.createElement('img');
                mediaEl.src = path;
            }

            wrapper.appendChild(mediaEl);
            wrapper.appendChild(delBtn);

            // Insert at cursor
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                // Check if range is inside editor
                if (editor.contains(range.commonAncestorContainer)) {
                    range.deleteContents();
                    range.insertNode(wrapper);
                    // Move cursor after
                    range.setStartAfter(wrapper);
                    range.setEndAfter(wrapper);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    return;
                }
            }
            // Fallback append
            editor.appendChild(wrapper);
        }

        /* --- MARKDOWN <-> HTML CONVERTER --- */

        function markdownToEditorHtml(md) {
            if (!md) return "";
            let html = md;

            // Escape HTML first to prevent XSS from source
            html = html.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

            // Images: ![alt](url) -> wrapper
            html = html.replace(/!\[.*?\]\((.*?)\)/g, (match, src) => {
                return createMediaHtml(src, 'image');
            });

            // Videos: &lt;video src="url" ...&gt;&lt;/video&gt;
            html = html.replace(/&lt;video src="(.*?)"(.*?)&gt;&lt;\/video&gt;/g, (match, src) => {
                return createMediaHtml(src, 'video');
            });

            // Newlines to <br>
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        function createMediaHtml(src, type) {
            const tag = type === 'video' ? `<video src="${src}" controls></video>` : `<img src="${src}">`;

            return `<span class="media-wrapper" contenteditable="false" draggable="true" ondragstart="draggedMediaElement = this; event.dataTransfer.effectAllowed = 'move';">
                ${tag}
                <button class="media-delete" onmousedown="event.preventDefault(); this.parentElement.remove();">x</button>
            </span>`;
        }

        function editorHtmlToMarkdown(html) {
            // Create a temp div to parse
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // Process nodes
            let md = "";

            // Helper to traverse
            function traverse(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    return node.textContent;
                }
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();

                    if (node.classList.contains('media-wrapper')) {
                        const img = node.querySelector('img');
                        const vid = node.querySelector('video');
                        if (img) return `\n![Image](${img.getAttribute('src')})\n`;
                        if (vid) return `\n<video src="${vid.getAttribute('src')}" controls style="max-width:100%; border-radius:4px; margin:10px 0;"></video>\n`;
                        return "";
                    }

                    if (tagName === 'br') return "\n";
                    // For other elements, just get their text content.
                    // The contenteditable div is expected to hold raw markdown text,
                    // so we don't need to interpret h1, h2, etc. tags.
                    // We just want the raw text, and media wrappers converted.
                    return Array.from(node.childNodes).map(traverse).join('');
                }
                return "";
            }

            md = Array.from(temp.childNodes).map(traverse).join('');

            // Cleanup multiple newlines
            return md.replace(/\n{3,}/g, "\n\n").trim();
        }

        async function uploadImage(file, folderName) {
            const formData = new FormData();
            // IMPORTANT: Append folder BEFORE file for Multer to know destination
            if (folderName) formData.append('folder', folderName);
            formData.append('image', file);

            const res = await fetch('/api/upload', { method: 'POST', body: formData });
            if (!res.ok) throw new Error('Upload failed');
            const data = await res.json();
            return data.path;
        }

        function dataURItoBlob(dataURI) {
            // Check if it's actually a data URI
            if (!dataURI.startsWith('data:')) return null;

            try {
                const byteString = atob(dataURI.split(',')[1]);
                const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                return new Blob([ab], { type: mimeString });
            } catch (e) {
                console.error("Invalid Data URI", e);
                return null;
            }
        }

        async function deleteSelected() {
            if (confirm('Confirm deletion of selected protocols? This will permanently delete associated media files.')) {

                const toDelete = recipes.filter(r => selectedIds.has(r.id));

                for (let r of toDelete) {
                    // Attempt to determine folder path
                    // 1. Try from title convention
                    const folderName = r.title.trim().replace(/[^a-z0-9\-_]/gi, '_');
                    const folderPath = '/recipes/medias/' + folderName;

                    console.log("Deleting folder:", folderPath);
                    try {
                        await fetch('/api/folder', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: folderPath })
                        });
                    } catch (e) {
                        console.error("Failed to delete folder for " + r.title, e);
                    }
                }

                recipes = recipes.filter(r => !selectedIds.has(r.id));
                selectedIds.clear();
                toggleSelectMode();
                await saveData();
                displayedCount = 0;
                renderGrid();
            }
        }

        function exportData() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(recipes));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "recipes_backup_" + new Date().toISOString().slice(0, 10) + ".json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        /* --- PAPRIKA & ZIP IMPORT LOGIC --- */

        async function handleFileImport(input) {
            const files = input.files;
            if (!files || files.length === 0) return;

            let count = 0;
            let imported = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const name = file.name.toLowerCase();

                try {
                    let fileRecipes = [];
                    if (name.endsWith('.paprikarecipes')) {
                        fileRecipes = await importPaprikaArchive(file);
                    } else if (name.endsWith('.paprikarecipe')) {
                        const r = await importPaprikaSingle(file);
                        if (r) fileRecipes = [r];
                    } else if (name.endsWith('.json')) {
                        fileRecipes = await importJsonFile(file);
                    }

                    if (fileRecipes && fileRecipes.length > 0) {
                        imported.push(...fileRecipes);
                        count++;
                    }
                } catch (err) {
                    console.error('Import failed for', name, err);
                }
            }

            if (imported.length > 0) {
                showToast(`Processing ${imported.length} recipes...`);

                for (let r of imported) {
                    await processRecipeImages(r);

                    const idx = recipes.findIndex(ex => ex.id === r.id);
                    if (idx >= 0) {
                        recipes[idx] = r; // Update existing
                    } else {
                        recipes.push(r); // Add new
                    }
                }

                await saveData();
                alert(`${imported.length} recipes processed successfully.`);
                renderGrid();
            }
            input.value = '';
        }

        async function processRecipeImages(recipe) {
            if (!recipe.images || recipe.images.length === 0) return;

            const newImages = [];
            const folder = recipe.title.trim().replace(/[^a-z0-9\-_]/gi, '_');

            for (let img of recipe.images) {
                if (img.startsWith('data:')) {
                    const blob = dataURItoBlob(img);
                    if (blob) {
                        const ext = blob.type.split('/')[1] || 'jpg';
                        const file = new File([blob], `imported.${ext}`, { type: blob.type });
                        try {
                            const path = await uploadImage(file, folder);
                            newImages.push(path);
                        } catch (e) {
                            console.error("Failed to upload imported image", e);
                        }
                    }
                } else {
                    newImages.push(img);
                }
            }
            recipe.images = newImages;
        }

        async function importPaprikaArchive(file) {
            const zip = await JSZip.loadAsync(file);
            const entries = Object.keys(zip.files);
            const newRecipes = [];

            for (const name of entries) {
                if (name.toLowerCase().endsWith('.paprikarecipe')) {
                    const entry = zip.files[name];
                    const uint8 = await entry.async('uint8array');
                    try {
                        const jsonStr = pako.ungzip(uint8, { to: 'string' });
                        const obj = JSON.parse(jsonStr);
                        newRecipes.push(mapPaprikaToApp(obj));
                    } catch (e) { console.warn("Skipping bad entry", name); }
                }
            }
            return newRecipes;
        }

        async function importPaprikaSingle(file) {
            const buffer = new Uint8Array(await file.arrayBuffer());
            const jsonStr = pako.ungzip(buffer, { to: 'string' });
            const obj = JSON.parse(jsonStr);
            return mapPaprikaToApp(obj);
        }

        async function importJsonFile(file) {
            const text = await file.text();
            const json = JSON.parse(text);
            let res = [];
            if (Array.isArray(json)) {
                res = json.map(mapPaprikaToApp);
            } else if (json.uid) {
                res = [mapPaprikaToApp(json)];
            } else {
                res = [json];
            }
            return res;
        }

        function mapPaprikaToApp(p) {
            // Check if already normalized (native)
            if (p.id && p.title && !p.uid) return p;

            // Handle image logic
            let imgs = [];
            if (p.photo_data) imgs.push('data:image/jpeg;base64,' + p.photo_data);
            else if (p.image_url) imgs.push(p.image_url);
            else if (p.photo) imgs.push('/recipes/media/' + p.photo); // Local media path assumption

            // Parse Ingredients from string to array
            let ings = [];
            if (typeof p.ingredients === 'string') {
                ings = p.ingredients.split('\n').filter(l => l.trim()).map(parseIngredient);
            }

            return {
                id: p.uid || crypto.randomUUID(),
                title: p.name || "Untitled",
                prepTime: p.prep_time || "",
                cookTime: p.cook_time || "",
                servings: parseInt(p.servings) || 4,
                tags: p.categories || [],
                images: imgs,
                ingredients: ings,
                steps: p.directions || "", // Markdown parser handles strings well
                createdAt: p.created ? new Date(p.created).getTime() : Date.now() // Use existing date or now
            };
        }

        async function importFromUrl() {
            const url = prompt("Enter Recipe URL:");
            if (!url) return;

            showToast("Scraping recipe...");

            try {
                const res = await fetch('/api/import-recipe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                if (!res.ok) throw new Error((await res.json()).error || 'Failed to fetch');

                const data = await res.json();

                // Map to App Structure
                const newRecipe = {
                    id: crypto.randomUUID(),
                    title: data.title,
                    prepTime: data.prepTime,
                    cookTime: data.cookTime,
                    servings: data.servings,
                    tags: [],
                    ingredients: data.ingredients.map(parseIngredient),
                    steps: data.instructions,
                    images: data.imageUrl ? [data.imageUrl] : [],
                    createdAt: Date.now()
                };

                openEditModal(newRecipe);
                showToast("Recipe imported! Review and Save.");

            } catch (e) {
                console.error(e);
                alert("Import failed: " + e.message);
            }
        }

        /* --- NEW EDIT FEATURES --- */

        function handleEditorFocus() {
            const editor = document.getElementById('editSteps');
            if (editor.classList.contains('preview-mode')) {
                // Switch back to Edit Mode
                editor.innerHTML = markdownToEditorHtml(currentRawMarkdown);
                editor.classList.remove('preview-mode');
            }
        }

        function handleEditorBlur() {
            const editor = document.getElementById('editSteps');
            // Save current state
            currentRawMarkdown = editorHtmlToMarkdown(editor.innerHTML);
            // Render Preview
            editor.innerHTML = marked.parse(currentRawMarkdown);
            editor.classList.add('preview-mode');
        }

        function insertMarkdown(prefix, suffix) {
            const editor = document.getElementById('editSteps');
            editor.focus();

            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                if (editor.contains(range.commonAncestorContainer)) {
                    const text = range.toString();
                    document.execCommand('insertText', false, prefix + text + suffix);
                    return;
                }
            }
        }

        function handleMediaDragOver(e) {
            if (draggedMediaElement) {
                e.preventDefault(); // Allow drop
                e.dataTransfer.dropEffect = 'move';

                // Visual Feedback: Move caret to hover position
                let range = null;
                if (document.caretRangeFromPoint) {
                    range = document.caretRangeFromPoint(e.clientX, e.clientY);
                } else if (document.caretPositionFromPoint) {
                    const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
                    range = document.createRange();
                    range.setStart(pos.offsetNode, pos.offset);
                    range.collapse(true);
                }

                const editor = document.getElementById('editSteps');
                if (range && editor.contains(range.commonAncestorContainer)) {
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
        }

        function handleMediaDrop(e) {
            if (draggedMediaElement) {
                e.preventDefault();
                const editor = document.getElementById('editSteps');

                let range = null;
                if (document.caretRangeFromPoint) {
                    range = document.caretRangeFromPoint(e.clientX, e.clientY);
                } else if (document.caretPositionFromPoint) {
                    const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
                    range = document.createRange();
                    range.setStart(pos.offsetNode, pos.offset);
                    range.collapse(true);
                }

                if (range && editor.contains(range.commonAncestorContainer)) {
                    range.insertNode(draggedMediaElement);
                    // Place cursor after
                    range.setStartAfter(draggedMediaElement);
                    range.collapse(true);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                draggedMediaElement = null;
            }
        }

        function switchEditTab(tabName, btn) {
            // Update Buttons
            if (btn) {
                document.querySelectorAll('.mobile-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }

            // Update Panels
            const details = document.getElementById('editTabDetails');
            const steps = document.getElementById('editTabSteps');

            if (tabName === 'details') {
                details.classList.add('active-tab');
                steps.classList.remove('active-tab');
            } else {
                details.classList.remove('active-tab');
                steps.classList.add('active-tab');
            }
        }

        function toggleMobileMenu() {
            const menu = document.getElementById('secondaryControls');
            menu.classList.toggle('show-menu');
        }

        // Close menu when clicking outside
        document.addEventListener('click', function (event) {
            const menu = document.getElementById('secondaryControls');
            const btn = document.getElementById('mobileMenuBtn');
            if (window.innerWidth <= 900 && menu.classList.contains('show-menu') && !menu.contains(event.target) && !btn.contains(event.target)) {
                menu.classList.remove('show-menu');
            }
        });

        function toggleSearchClearBtn() {
            const input = document.getElementById('searchInput');
            const btn = document.getElementById('searchClearBtn');
            if (input.value.length > 0) {
                btn.style.display = 'block';
            } else {
                btn.style.display = 'none';
            }
        }

        function clearSearch() {
            const input = document.getElementById('searchInput');
            input.value = '';
            toggleSearchClearBtn();
            renderGrid(true);
            input.focus();
        }

        /* --- LIGHTBOX LOGIC --- */
        let currentLightboxIndex = 0;

        function openLightbox() {
            if (!currentActiveRecipe || !currentActiveRecipe.images || currentActiveRecipe.images.length === 0) return;

            // Find index of currently displayed image
            const currentSrc = document.getElementById('modalMainImage').src;
            // Handle full URL vs relative path issues by checking endsWith or just finding exact match
            // Simple approach: find exact match or default to 0
            let idx = currentActiveRecipe.images.findIndex(img => currentSrc.includes(img));
            if (idx === -1) idx = 0;

            currentLightboxIndex = idx;
            updateLightboxImage();
            document.getElementById('lightboxOverlay').classList.add('active');
        }

        function closeLightbox(e) {
            // Close if clicking overlay or close button, but not if clicking image or nav (unless nav handles it)
            if (e && e.target.id !== 'lightboxOverlay' && !e.target.classList.contains('lightbox-close')) return;

            document.getElementById('lightboxOverlay').classList.remove('active');
        }

        function navigateLightbox(dir, e) {
            if (e) e.stopPropagation();
            if (!currentActiveRecipe || !currentActiveRecipe.images) return;

            const len = currentActiveRecipe.images.length;
            currentLightboxIndex = (currentLightboxIndex + dir + len) % len;
            updateLightboxImage();
        }

        function updateLightboxImage() {
            const img = document.getElementById('lightboxImage');
            img.src = currentActiveRecipe.images[currentLightboxIndex];
        }

        // Swipe for Lightbox
        let lbStartX = 0;
        const lbOverlay = document.getElementById('lightboxOverlay');

        lbOverlay.addEventListener('touchstart', e => {
            lbStartX = e.touches[0].clientX;
        }, { passive: true });

        lbOverlay.addEventListener('touchend', e => {
            const endX = e.changedTouches[0].clientX;
            const diff = lbStartX - endX;
            if (Math.abs(diff) > 50) {
                if (diff > 0) navigateLightbox(1); // Swipe Left -> Next
                else navigateLightbox(-1); // Swipe Right -> Prev
            }
        }, { passive: true });

    </script>
</body>

</html>